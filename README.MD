# Start quickly.
``` cargo run test1.o.elf
```


# Presentation.
I am Gaspard COURCHINOUX, I am a (former) student of M2 labour law and social protection, I am passionate about computer science.

I have written this emulator to learn the instruction set (ISA) RISCV32.

I think that the future is RISCV and I find this architecture very seditious in particular by its simplicity. The code you are reading is written in RUST with few dependencies.
It's not perfect: I try to make a functional and readable code for as many people as possible.

The licence is the general public licence Gnu v3.

You can read it : gpl-3.0.md
If you have any questions, don't hesitate to write to me: 
gaspard.courchinoux@protonmail.ch


# Information flow.

Remul32 is an emulator that has been built in the perspective of being readable and easily debugable.

Remul32 takes as input an ELF file (executable linkable format) pre-compiled with a Clang/LLVM or GCC/BIUNTILS compiler.

The tests were conducted on GCC/BINUTILS mainly.

Even though CLANG llvm is a more modern and secure compiler.

The file is open, the section: .TEXT is uncompiled.
Also, the instructions are copied into a matrix (Vec) that serves to represent the memory.

They are copied from the start address provided by the ELF file.

# Memory Management.

Remul32 wants to be light, he does not request a continuous allocation of a large memory block.

The memory is allocated according to the operations of LOAD/STORE, if the program copies 300 bytes: 300 bytes will then be allocated.


# Supported instructions.
File :  Decoder.RS



All RISCV instructions (~1426) including extensions are supported.

Of course, I'm alone, I can't write the 1426 emulation code instructions.

It would be too long...

If you want to contribute (most of the work consists of adding instructions) do not hesitate to clone this deposit and make a PULL request.

I will be very honoured with your dedication! 

The instructions supported are RV32I.

Nevertheless, all instructions are taken into account.

The one I didn't implement is simply ignored.
RVC is detected, but not known yet.

# Program internal.

The Decoder.RS was partially generated by RISCV-OPCODES, a python program provided by the RISCV Foundation.
It allows to generate rough files,c etc..

I modified the python program to generate a RUST file that meets my expectations.
The Decoder file.rs is a central file, the most important of the program.
This file implements a structure that is DecoderStruct.
It implements the matrix containing the memory.



```

pub struct DecoderStruct{


adress_begin :u64,

adress_instructions : &'a [u8],




memory: Vec,

section_instr_size: u32,
regs: [u64; 33],

// faire les drapeaux




carry : bool,
negative: bool,
zero : bool,
equal : bool ,
overflow: bool ,
greater_than : bool,
greater_than_equal : bool,
less_than_equal : bool,
less_than : bool,


adress_debut_fonction : u64,
adress_begin_section : u64,


}

```




To implement a new instruction, you must imperatively write the code in normal_scan method.

The self variable contains the DecoderStruct structure.

You must do the action of the instruction using this structure.

# the rest.

Additional instructions should be added and execution bugs fixed in particular in the beq etc and JALR instructions, JAL.

# To contact me.

Don't hesitate if you have any questions.

gaspard.courchinoux@protonmail.ch
https://courchinoux.org
